// 输入描述:
// 输入的第 1 行，为两个正整数，用一个空格隔开：N m
// （其中 N （ <32000 ）表示总钱数， m （ <60 ）为希望购买物品的个数。）
// 从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q
// （其中 v 表示该物品的价格（ v<10000 ）， p 表示该物品的重要度（ 1 ~ 5 ）， q 表示该物品是主件还是附件。
// 如果 q=0 ，表示该物品为主件，如果 q>0 ，表示该物品为附件， q 是所属主件的编号）
// 输出描述:
//  输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（ <200000 ）。

// 0-1背包问题
// 0-1背包（二维）：
// 问题：共n个物体，第i个重量为w[i]，价值v[i]，背包最多能背不超过W的物体，求最大的价值
// 设置二维数组 dp[ i ][ j ]; i 代表第 i 个物体，j 代表当前容量，
// dp[ i ][ j ]代表的是前 i 个物体在容量为 j 请情况下所能得到的最大价值。
// 假设前 i-1 个物品的状态都已经更新完毕(即前 i-1 个物品在每一种容量下的最大价值都已经确定)，
// 对于第 i 个物品在容量为 j 是否可以加入到背包当中，有两种情况：
// 情形一：第 i 个物品不可以加入到背包中，那么dp[ i ][ j ] = dp[ i-1 ][ j ]; 因为容量不变，物品数没有增加，价值量就不变
// 情形二：第 i 个物品可以加入到背包当中，那么我们需要考虑的是，把它加进来价值高，还是不加进来价值高。
// 		取两者之间的最大值。同时加进来的话当前容量必须空出可以让这个物品加进来的容量。
// 因此0-1背包 二维解法递归核心：
// for(i = 1; i<=n; i++)
// {
//     for(j = 0; j<=W; j++)
//     {
//         if(j<w[i])
//             dp[i][j] = dp[i-1][j];
//         else
//             dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]);
//     }
// }
// 0-1背包（一维）：
// 降维：减行，第i个物体的更新，只依赖于第i-1个的物体的结果
// 所以可以用滚动数组，每次只存i和i-1时候的值 （可得：dp[n][W] → dp[2][W] ）
// 删行，第i个物体在容积为j状态的更新，只依赖i-1物体容量里j-w[i]的状态的结果
// 所以，从后面开始向前更新，则求j位置时候，j-w[i]的值依旧为i-1时候的值（可得：dp[2][W] → dp[W] ）
// 一维0-1背包的核心：
// for(int i=1; i<n; i++){
//     for(int j=W; j>=w[i]; j--){
// 	dp[j] = max(dp[j], dp[j-w[i]]+value[i]);
//     }
// }
// 分组背包：
// 有N件物品，告诉你这N件物品的重量以及价值，将这些物品划分为K组，每组中的物品互相冲突，最多选一件，
// 求解将哪些物品装入背包可使这些物品的费用综合不超过背包的容量，且价值总和最大。
// 首先0-1背包问题是一种特殊的分组背包问题，n个物品就是n个组
// 分组背包的核心思想：
// for 所有的组k{
//     for j=0..W{  //每组中选定方式的不同，会使对容量的需求不同，因此容量遍历从W到0
// 	for 所有的i属于组k{   //第k组中有多个不同的物品 第k组不同的i代表当第k组不同的物品
// 	    dp[j]=max{dp[j],dp[j-w[i]]+v[i]}; //意味着当前容量j下，所能得到的最大价值，来源于上一层的某一种选择（上一层总共有i+1种选择），这点保证了每一组都只会选择一种物品或者是0种物品
// 	}		
//     }
// }
// 依赖的背包问题：
// 本题购物单，就是一个典型的依赖的背包问题。我们按照每个主件一定有两个配件来处理，如果输入只给了一个配件，
// 那么另一个配件的权重和花费都为0。这个时候我们对这个主件和配件的选择构成了一组中的不同物品：
// 1. 仅主件
// 2.主件+配件1
// 3.主件+配件2
// 4.主件+配件1+配件2
// 也就是说，对于输入的数据，有依赖关系的主件和配件，我们要把它处理成前4种形式当做一组，
// 代表一组四种可选择的物品，在此基础上我们也可以什么都不选。所以每组是五种选择方式
// 自此，得到 k 组物品，按照分组背包问题解决即可

#include <iostream>
#include <algorithm>
using namespace std;
 
int main()
{
	int W; //代表所允许的总消费，即最大容量
	int m; //代表总共有N个组件
	
	while(cin >> W >> m)
	{
		int weight[100][3] = {0}; //记录每个主件及其附件的金额（容量）
		int value[100][3]  = {0}; //记录每个主件及其附件的价值（价值=金额*权重） 
		 
		for(int i=1; i<=m; i++)
		{ 
			int v; //代表当前组件的金额（容量）
			int p; //代表当前组件的权重 
			int q; //代表当前组件是主件还是附件，如果为附件，q代表其对应的主件的编号（注意主件编号并不是连续的） 			
			cin >> v >> p >> q; 			
			v /= 10; //缩小单个配件的价格（容量） 			
			if( q==0 )
			{
				weight[i][0] = v;
				value[i][0] = v*p;
			}
			else
			{
				if( weight[q][1]==0 )
				{
					weight[q][1] = v;
					value[q][1] = v*p;
				}
				else
				{
					weight[q][2] = v;
					value[q][2] = v*p;
				}
			}
		}	
		int dp[3200] = {0}; //dp总容量为3200 
		W /= 10; //缩小最大容量的范围，因为金额是10的倍数 
		for(int i=1; i<=m; i++)
		{
			if( weight[i][0]==0 ) //跳过无效组 
			{
				continue;
			} 
	    	for(int j=W; j>0; j--)
	    	{
	            if(j >= weight[i][0])       //只容纳主件对 dp[j]进行更新 
	                dp[j] = max(dp[j], dp[j-weight[i][0]] + value[i][0]);
	            if(j >= weight[i][0] + weight[i][1]) //在已经考虑只容纳主件的基础上，容纳主件和附件1对dp进行更新 
	                dp[j] = max(dp[j], dp[j-weight[i][0]-weight[i][1]] + value[i][0] + value[i][1]);
	            if(j >= weight[i][0] + weight[i][2]) //在之前的基础上，容纳主件和附件2对dp进行更新
	                dp[j] = max(dp[j], dp[j-weight[i][0]-weight[i][2]] + value[i][0] + value[i][2]);
	            if(j >= weight[i][0] + weight[i][1] + weight[i][2]) //在之前的基础上，容纳主件、附件1、附件2对dp进行更新 
	                dp[j] = max(dp[j], dp[j-weight[i][0]-weight[i][1]-weight[i][2]] + value[i][0] + value[i][1] + value[i][2]);
	        }
		} 
		cout << dp[W] * 10 << endl; 
	}	
	return 0;
}
 