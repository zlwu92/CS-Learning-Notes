问：NULL和nullptr的区别？
在C语言中，NULL通常被定义为：#define NULL ((void *)0)，所以说NULL实际上是一个空指针
但在C++程序中的NULL中，实际上编译器提供的头文件做了相应的处理：
#ifdef __cplusplus
#define NULL 0
#else
#define NULL ((void *)0)
#endif。            可见，在C++中，NULL实际上是0. 
为解决NULL代指空指针存在的二义性问题，在C++11版本(2011年发布)中引入了nullptr 关键字来代指空指针！

问：++i 和 i++ 哪个效率更高？
内置数据类型，效率没有区别；自定义类型，++i效率较高
++i先自增1，再返回；i++先返回，再自增1

问：main 函数执行以前，还会执行什么代码？
全局对象的构造函数会在main 函数之前执行。
main函数执行之前，主要就是初始化系统相关资源：
设置栈指针
初始化静态static变量和global全局变量，即.data段的内容
将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容
全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码
将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数
main函数执行之后：
全局对象的析构函数会在main函数之后执行；

问：判断处理器 大端 和 小端？
- 小端的CPU对操作数的存放方式是：从低字节 到 高字节；数据的低字节存储在低地址中
- 大端的CPU对操作数的存放方式是：从高字节 到 低字节；数据的高字节存储在低地址中
- 联合体union的存放顺序是从低地址开始存放的
方式一：使用强制类型转换-这种法子不错
int main()
{
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout << "big endian" << endl;
    else if(c == 0x34)
        cout << "little endian" << endl;
}

问：strcpy 和 memcpy的区别？
- 复制内容不同，memcpy可以复制任何存于内存的内容
- 复制方法不同，strcpy不需要指定长度，memcpy需要传参
- 用途不同，复制字符串用strcpy，其他考虑memcpy
手动实现strcpy
char *strcpy(char *strDest, const char *strSrc)
{
	if ( strDest == NULL || strSrc == NULL)
		return NULL ;
	if ( strDest == strSrc)
		return strDest ;
	char *tempptr = strDest ;
	while( (*strDest++ = *strSrc++) != ‘/0’)	return tempptr ;
}

问：memcpy的源地址与目的地址有交集会有影响吗，如何解决？
从最后一个字节倒着开始复制。

问：memory alignmentand padding, 内存对齐的原理与意义（提问概率：★★★★）
结构体以及类成员对齐，意义就是减少cpu读取的次数，提高效率。
比如一个int变量长度为4个字节，cpu一次读4个字节，当然是一次读取比较好。
但是如果前面有一个char，地址为0-1。那么这个int的地址就为1-4。导致cpu，分两次读取int值。 
具体的对齐规则，要说的非常准确可能比较麻烦，简单来讲就是，每个变量看后面的变量，如果后面的变量大，就和后面的大小对齐并补充字节。
最后一个变量，按照成员内最大的对齐值，对齐并补充字节。
问：如何让数组首地址按照32字节对齐？
(arr + 31) & E0 --> E0 = 1110 0000，按照32字节对齐，就是要首地址被32整除，则需要最后5个bit为0；

问：如何关闭内存对齐呢？
添加预处理指令 #pragma pack(1) 

问：简述extern"C"的作用
- extern用来声明或者引用一个全局变量
- C函数需要利用extern "c"进行链接指定，告诉编译器，不要改变我的名字。
- 由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；
  而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般之包括函数名。

问：请说出const与#define相比，有何优点？
const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。
1）const常量有数据类型，而宏常量没有数据类型。
2）编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。
3）有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试
#define只是用来做文本替换的，编译期概念。 存在于程序的代码段，无类型检测。
const存在于程序的数据段，在堆栈分配空间，是一个运行时的概念，可以做类型检查。

问：const 有什么作用？
- const用于定义常量，可以进行数据静态类型安全检查
- const用于修饰函数形参，当传入自定义类型和抽象类型时，应该用const&，避免产生临时对象，提高效率
- const修饰函数的返回值，则返回值不能被修改
- const修饰类的成员函数
- 对于全局变量，const存于全局区，对于字面值常量，存于常量存储区，对于局部变量，存于栈区
(重要！)类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（准确地说是非静态数据成员）作任何改变。

问：mutable关键字:
- 被mutable修饰的变量，将永远处于可变的状态
- mutable在类中只能够修饰非静态数据成员
- 我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。
  但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。
- const方法中不允许对常规成员进行变动，但mutable成员不受此限制
volatile关键字:
- “易变”是相对与普通变量而言其值存在编译器(优化功能)未知的改变情况(即不是通过执行代码赋值改变其值的情况)
  而是因外在因素引起的，如多线程，中断等。
- volatile用于修饰成员或变量，指示其修饰对象可能随时变化，编译器不要对所修饰变量进行优化(缓存)，每次取值应该直接读取内存。
总结：
- mutable只能用与类变量，不能与const同时使用；在const修饰的方法中，mutable变量数值可以发生改变；
- volatile只是运行期变量的值随时可能改变，这种改变即可能来自其他线程，也可能来自外部系统。


问：new 和 malloc的区别？
1、 new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持；
2、 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。
3、 new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。
而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
4、 new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
5、 new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。
delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。
malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

问：malloc的底层实现
- 当开辟的空间小于 128K 时，调用 brk()函数，malloc 的底层实现是系统调用函数 brk()，
  其主要移动指针 _enddata(此时的 _enddata 指的是 Linux 地址空间中堆段的末尾地址，不是数据段的末尾地址)
- 当开辟的空间大于 128K 时，mmap()系统调用函数来在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟。

问：有了malloc/free，为什么还要new/delete？
对于非内置数据类型的对象，对象在销毁之前要自动执行析构函数，
而malloc/free是库函数不是运算符，不在编译器控制范围，
不能把构造函数和析构函数强加于malloc/free，只能使用new/delete运算符

问：简要说明C++的内存分区
C++中的内存分区，分别是栈、堆(new)、自由存储区(malloc)、全局/静态存储区、常量存储区和代码区。依次从高地址->低地址

问：内存分配的方式有几种？
- 从静态存储区分配：编译期就分配好，在整个运行期都存在
- 在栈上创建：函数内部的局部变量
- 在堆上创建：生命期由程序员控制


问：说说static关键字的原理？（隐藏、持久！）
静态函数会被自动分配在一个一直使用的存储区，直到退出应用程序实例，避免了调用函数时压栈出栈，速度快很多。
static函数（也叫内部函数）只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用。区别于一般的非静态函数（外部函数）
static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；
static成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；
虚函数的调用关系，this->vptr->ctable->virtual function

问：static关键字的作用？
- 在函数体内，一个被声明为static的变量在函数调用中保持不变；
- 在模块内（但在函数体外），一个被声明为static的变量是一个本地cpp的全局变量；
- 在模块内，一个被声明为static的函数只可被本模块内的其他函数调用；

问：static全局变量与普通的全局变量有什么区别？
- static全局变量只初始化一次，为0，防止在其他文件中被引用
- static函数在内存中只有一份，保存在静态存储区，生命周期整个程序运行期间，普通函数每次被调用时都会维持一份copy
- 类的static成员供所有对象使用，不是对象的成员，因此引用不需要对象名。static函数不能调用非static成员。

问：关于this指针你知道什么？全说出来
this指针是类的指针，指向对象的首地址。
this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。
this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。

问：什么是this指针？
对于一个类的实例来说，你可以看到它的成员函数、成员变量， 　　
对于一个实例本身，this是一个指针，它时时刻刻指向你这个实例本身。
作用域：this指针是编译器默认传给类中非静态函数的隐含形参，所以其作用域在非静态成员函数的函数体内。
this是一个常量指针，成员函数的其它参数正常都是存放在栈中。而this指针参数则是存放在 register 中。
- 类的非static函数是类的对象，含有this指针；而类的static函数属于类的本身，不含this指针
- friend函数是非成员函数，无法通过this指针获取

问：为什么要引入inline函数？
- 主要目的是 用它替代 C中的宏定义（缺点是 不能对参数进行有效的检测，返回值也不能被强制转换，存在隐患和局限）

问：inline比宏定义的优势在哪？
- inline定义的类的函数，代码是被放入符号表中的，在使用时直接进行替换（像宏一样展开），无调用开销
- inline函数也是函数，编译器会对其进行一些列检查，消除了安全隐患
- inline作为成员函数时，还能使用类中的protected和private成员变量

问：inline与宏的区别在哪？
- inline在 编译 时展开，宏在 预编译 时展开
- inline是函数，宏不是函数
- 编译时，inline函数直接被镶嵌到目标代码中，宏只是一个简单的文本替换

问：inline函数的使用场合
通常把类中对于protected和private的成员的读写操作接口定义成inline

问：为什么不把所有函数定义成inline？
inline是以代码膨胀为代价的，仅仅是省去了函数调用的开销。
- if 函数体内代码很大，inline导致内存开销大
- if 函数体内出现循环，执行函数体内的代码比函数调用开销大
- 不应该把constructor和destructor定义成inline，不应该出现在类的声明中

问：什么是“野指针”？
野指针 不是 NULL 指针，而是指向“垃圾”内存的指针
- 指针没有被初始化
- 指针被free或者delete以后，没有置为NULL

问：指针和引用有什么区别？
- 初始化要求不同，引用必须初始化。
- 可修改性不同，引用初始化后不可改变，指针可以随时改变
- 不存在NULL引用，指针可以
- 测试需要的区别，引用不需要测试合法性，指针需要测试

问：为什么传引用比传指针安全？
指针可以随时指向别的对象，可以不初始化，可能产生野指针！

问：C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？
1) 指针参数传递本质上是值传递，它所传递的是一个地址值。
2) 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。
3) 引用传递和指针传递是不同的，任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。
4) 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。

问：什么情况用指针当参数，什么时候用引用，为什么？
1)  使用引用参数的主要原因有两个：
程序员能修改调用函数中的数据对象；
通过传递引用而不是整个数据–对象，可以提高程序的运行速度。

问：指针常量 和 常量指针的区别？
常量指针：指向常量的指针，所指内容不可修改；const int* p; or int const* p;
指针常量：是不可改变地址的指针，但可以对他所指内容进行修改，int * const p;

问：指针数组 和 数组指针的区别？
指针数组：是一个数组，数组中的每个元素都是指针 int* p[10];
数组指针：是一个指针，指向一个数组的首地址 int* p = new int[10];

问：函数指针 和 指针函数的区别？
指针函数：是返回指针类型的函数 void *func(){ return pointer;}
函数指针：是指向函数地址的指针 void (*p)(int, int);
typedef关键字可以定义一个函数指针类型；

问：区别以下指针类型？
int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。
int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。

问：final和override的作用，以及使用场合（提问概率：★★）
final:禁止继承该类或者覆盖该虚函数
override:必须覆盖基类的匹配的虚函数
场合（final）:不希望这个类被继承，比如vector，编码者可能不够了解vector的实现，或者说编写者不希望别人去覆盖某个虚函数
场合（override）:第一种，在使用别人的函数库，或者继承了别人写的类时，想写一个新函数，可能碰巧与原来基类的函数名称一样，被编译器误认为要重写基类的函数。
第二种情况是想覆写一个基类的函数，但是不小心参数不匹配或者名字拼错，结果导致写了一个新的虚函数

问：内存泄露是什么意思？如何检测与避免内存泄漏？（提问概率：★★★★）
指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。
内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，
由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。

问：什么是内存碎片？
描述一个系统中所有的不可用的空闲内存，原因在于空闲内存以小而不连续方式出现在不同的位置。
缺点：大量的内存碎片会使系统缓慢，原因在于虚拟内存的使用会使内存与硬盘之间的数据交换称为系统缓慢的根源,最终造成内存的枯竭!
如何避免内存碎片的产生？
- 少用动态内存分配的函数(尽量使用栈空间)
- 分配内存和释放的内存尽量在同一个函数中
- 尽量一次性申请较大的内存2的指数次幂大小的内存空间，而不要反复申请小内存(少进行内存的分割)
- 使用内存池来减少使用堆内存引起的内存碎片，自己来管理

问：什么是内存屏障，内存屏障产生的原因？
若程序在执行的实际内存访问顺序和代码编写的访问顺序不一致，会导致 内存乱序访问！
内存乱序访问的出现 是为了提高程序执行时的效率。
内存乱序访问主要发生在如下两个阶段：
(1)编译时，编译器优化导致内存乱序访问；（可通过barrier函数来规避）
(2)运行时，多个cpu间交互引起的内存乱序访问。
使用内存屏障指令，存储器访问指令被分成数据指令+同步指令，其中weak consistency内存模型就是基于内存屏障指令。
内存屏障指令的基本原则是：
- 所有在内存屏障指令之前的data access必须在之前完成；
- 所有在内存屏障指令之后的data access必须等内存屏障指令执行完；
- 多条内存屏障指令是按顺序执行的。


