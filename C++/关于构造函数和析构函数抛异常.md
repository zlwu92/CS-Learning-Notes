为什么析构函数不能抛出异常？
```
1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如 资源泄漏 的问题。
2）通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。
```
Solutions：
1) 如果某个操作可能会抛出异常，class应提供一个普通函数（而非析构函数），来执行该操作。目的是给客户一个处理错误的机会。
2) 如果析构函数中异常非抛不可，那就用try catch来将异常吞下，
   必须要把这种可能发生的异常完全封装在析构函数内部，决不能让它抛出函数之外。

为什么构造函数失败应该抛出异常？
>构造函数可以抛出异常，new运算符保证不会出现内存泄漏，底层实现会在catch中抛出异常
构造函数private -- 主要目的就是避免外部构造此类。