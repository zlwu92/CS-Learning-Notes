问：STL迭代器如何实现？
1. 迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，
除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。
2. 迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历。

问：迭代器失效？
1. map移除元素会让迭代器失效
2. map增加元素并不会使迭代器失效, 因为map增加元素跟vector不一样, 
   vector要重新找一块内存把当前所有元素复制过去并释放原有元素所以会导致vector的迭代器失效, 
   但是map只是直接在红黑树上增加一个结点而已, 并不会移动原有元素, 内存没动, 自然map的迭代器不会失效了。

问：STL中map内部如何实现的？
```
map底层是 红黑树 实现的。
红黑树： 节点为红色or黑色
		叶子节点是空节点，黑色
		根节点是黑色
		如果父节点是红色，那么两个子节点都是黑色
		节点到其子孙节点的每条简单路径上都包含着相同数目的黑色节点
```
问：map插入方式有几种？
```
1)  用insert函数插入pair数据，
mapStudent.insert(pair<int, string>(1, "student_one")); 
2)  用insert函数插入value_type数据
mapStudent.insert(map<int, string>::value_type (1, "student_one"));
3)  在insert函数中使用make_pair()函数
mapStudent.insert(make_pair(1, "student_one")); 
4)  用数组方式插入数据
mapStudent[1] = "student_one"; 
```
问：map 和 hashmap有什么区别？

map分为有序map和无序map（unordered_map），实现的基本数据结构分别是 **红黑树与哈希表**。
- map的底层是红黑树，hashmap的底层是哈希表
- map中元素可以自动按照键值排序，hashmap各项操作平均复杂度接近常数
- map属于标准库的一部分，hashmap不是
```
hashmap里面常说的桶bucket就是vector数组的一个元素，每个桶里面的数据是以链表(开链)的形式存储，
进一步来说这些操作与定义都是通过一个基本的数据结构hashtable来实现的，
hashtable里面的hash函数就是常说的取模函数，根据存储数据key值对桶的长度取余数来存放。
改变桶的数量就相当于改变Vector的长度，如果超过vector的capacity就会调用Vector的扩容机制
（但是实际上他每次hash的时候都会直接调用vector的reserve进行扩容）。 
```
问：hashtable中解决冲突有哪些方法？
```
记住前三个：
【线性探测】
使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位
【开链】
每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中
【再散列】
发生冲突时使用另一种hash函数再计算一个地址，直到不冲突
【二次探测】
使用hash函数计算出的位置如果已经有元素占用了，按照、、…的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测
【公共溢出区】
一旦hash函数计算的结果相同，就放入公共溢出区
```