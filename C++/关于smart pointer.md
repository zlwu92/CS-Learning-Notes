问：智能指针如何实现？
- 每次创建类的新对象时，初始化指针并将引用计数 = 1；
- 当创建对象的副本时，拷贝构造函数拷贝指针并增加与之对应的引用计数；
- 对象进行赋值时，赋值操作减少左操作数的引用计数，增加右操作数的引用计数；
- 调用析构函数时，减少引用计数，如果为0，则删除对象；
- 重载的->以及*操作符，使得智能指针有类似于普通指针的操作

问：说说unique_ptr？
- unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。
- 采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。
- 一旦拥有着被销毁或变成 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。
- 一个unique_ptr独享它指向的对象。 也就是说，同时只有一个unique_ptr指向同一个对象，
- 当这个unique_ptr被销毁时，指向的对象也随即被销毁。
- unique_ptr不可复制，赋值，但是move()可以转换对象的所有权！

问：shared_ptr的实现，reference count在哪里定义（提问概率：★★★）
- shared_ptr ，多个指针指向相同的对象，std::make_shared 消除显式地使用 new
- shared_ptr作为一种智能指针，本质上一个模板类，表现上与指针相同，是因为重载了&以及*这两个运算符（当然还有=等运算符）。
- 由于其本身的计数机制，防止资源泄露上面很有意义。
- shared_ptr在实现上有两个核心的成员，一个是指向资源对象的指针变量，另一个是指向引用计数的指针变量。
- 另外，原生的shared_ptr的读写在多线程当中是不安全的，因为读写不具有原子性，所以多线程使用shared_ptr一定要加锁。
- 循环引用会造成内存泄露。

问：如果解决循环引用？
- 为了解决循环引用导致的内存泄漏，引入weak_ptr，不会修改引用计数的值。
- weak_ptr是为了配合shared_ptr而引入的一种智能指针，它不增加引用计数，只要出了作用域就会自动析构！
- weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。
- 但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。
- 使用weak_ptr的成员函数use_count()可以观测资源的引用计数，
- 另一个成员函数expired()的功能等价于use_count()==0，但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。
- weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。
- 但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。
