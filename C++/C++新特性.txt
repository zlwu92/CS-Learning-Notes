问：说一说你了解的关于lambda函数的全部知识
它定义了一个匿名函数，可以捕获一定范围的变量在函数内部使用，一般有如下语法形式：
auto func = [capture] (params) opt -> ret { func_body; };
其中func是可以当作lambda表达式的名字，作为一个函数使用，
capture是捕获列表，params是参数表，opt是函数选项(mutable之类)， ret是返回值类型，func_body是函数体。
lambda表达式允许捕获一定范围内的变量：
	[]不捕获任何变量
	[&]引用捕获，捕获外部作用域所有变量，在函数体内当作引用使用
	[=]值捕获，捕获外部作用域所有变量，在函数内内有个副本使用
	[=, &a]值捕获外部作用域所有变量，按引用捕获a变量
	[a]只值捕获a变量，不捕获其它变量
	[this]捕获当前类中的this指针

1) 利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；
2) 每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。
那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。
闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。
3) lambda表达式的语法定义如下：
[capture] （parameters） mutable ->return-type {statement};
4) lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；

c++11新增了std::function、std::bind、lambda表达式等封装使函数调用更加方便。
【std::function】
可以把std::function看做一个函数对象，用于表示函数这个抽象概念。
std::function的实例可以存储、复制和调用任何可调用对象，存储的可调用对象称为std::function的目标。
使用参考如下实例代码：
std::function<void(int)> f; // 这里表示function的对象f的参数是int，返回值是void。
从上面可以看到std::function的使用方法，当给std::function填入合适的参数表和返回值后，它就变成了可以容纳所有这一类调用方式的函数封装器。
【std::bind】
使用std::bind可以将可调用对象和参数一起绑定，绑定后的结果使用std::function进行保存，并延迟调用到任何我们需要的时候。

问：智能指针如何实现？
- 每次创建类的新对象时，初始化指针并将引用计数 = 1；
- 当创建对象的副本时，拷贝构造函数拷贝指针并增加与之对应的引用计数；
- 对象进行赋值时，赋值操作减少左操作数的引用计数，增加右操作数的引用计数；
- 调用析构函数时，减少引用计数，如果为0，则删除对象；
- 重载的->以及*操作符，使得智能指针有类似于普通指针的操作

问：说说unique_ptr？
unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。
采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。
一旦拥有着被销毁或变成 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。
一个unique_ptr独享它指向的对象。 也就是说，同时只有一个unique_ptr指向同一个对象，
当这个unique_ptr被销毁时，指向的对象也随即被销毁。
unique_ptr不可复制，赋值，但是move()可以转换对象的所有权！

问：shared_ptr的实现，reference count在哪里定义（提问概率：★★★）
shared_ptr ，多个指针指向相同的对象，std::make_shared 消除显式地使用 new
shared_ptr作为一种智能指针，本质上一个模板类，表现上与指针相同，是因为重载了&以及*这两个运算符（当然还有=等运算符）。
由于其本身的计数机制，防止资源泄露上面很有意义。
shared_ptr在实现上有两个核心的成员，一个是指向资源对象的指针变量，另一个是指向引用计数的指针变量。
另外，原生的shared_ptr的读写在多线程当中是不安全的，因为读写不具有原子性，所以多线程使用shared_ptr一定要加锁。
循环引用会造成内存泄露。

问：如果解决循环引用？
为了解决循环引用导致的内存泄漏，引入weak_ptr，不会修改引用计数的值。
weak_ptr是为了配合shared_ptr而引入的一种智能指针，它不增加引用计数，只要出了作用域就会自动析构！
weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。
但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。
使用weak_ptr的成员函数use_count()可以观测资源的引用计数，
另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。
weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。
但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。

问：RAII是什么？全称呢？和智能指针什么关系？
RAII:Resource Acquisition Is Initialization 资源分配即初始化，利用构造函数和析构函数定义一个类来完成对资源的分配和释放
智能指针主要用来防止内存泄漏
智能指针的思想就是RAII，就是利用对象的生命周期来管控资源的一种方式。
在对象构造时获取资源，把资源交给对象管理，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象析构的时候释放资源。
实际上是把管理一份资源的责任托管给了一个对象。
这种做法有两大好处：
不需要显式地释放资源；采用这种方式，对象所需的资源在其生命期内始终保持有效。

问：说说运行时类型信息 (RTTI)
dynamic_cast	用于多态类型的转换，只适用于指针或引用，向下转型是安全的
typeid 运算符允许在运行时确定对象的类型
type_id 返回一个 type_info 对象的引用
如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数
只能获取对象的实际类型
type_info 类描述编译器在程序中生成的类型信息。此类的对象可以有效存储指向类型的name的指针。
type_info 类还可存储适合比较两个类型是否相等 或 比较其排列顺序的编码值。
类型的编码规则和排列顺序是未指定的，并且可能因程序而异。
头文件：typeinfo

问：使用模板有什么缺点？如何避免？
- 模板是节省时间和避免代码冗余的方法
- 但不当的使用，会导致代码膨胀，严重影响程序的运行效率。（把模板中与参数无关的代码分离出来）

问：模板类和模板函数的区别是什么？
函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。
即函数模板允许隐式调用和显式调用而类模板只能显示调用。在使用时类模板必须加，而函数模板不必。

*****问：模板能放cpp文件里吗？
- 首先，只有模板实例化时，编译器才会得知 T 实参是什么。编译器在处理模板实例化时，不仅仅要看到模板的定义式，还需要模版的实现体。
- 当声明和定义分离时，因为 CTest.h 中只有该函数的声明而没有其定义，
  编译器此时希望链接器能够在其他 obj 文件中找到该函数的定义，但是由 CTest.cpp 中并没有使用该函数，
  所以 CTest.obj 中也无法找到该函数的定义，因此就会报该链接错误。
  对于模板来说，编译器在处理 CTest.cpp 文件时，编译器无法预知 T 的实参是什么，
  所以编译器对其实现是不作处理的（即 CTest.obj 中没有为编译器为实现体生成的对应的二进制代码）。
  现在有 main.cpp 真正使用了该模板，如果定义和实现分离，则编译器可以根据定义式生成模板类的对象
  （因为此处仅仅需要定义式就知道该对象在内存中需要多少空间并进一步分配了），
  但是调用对象的函数（即真正使用）需要该函数的定义，由于 main.cpp 仅仅 include 了模板的声明，所以无法找到该函数的定义。
- 声明和定义不分离：correct！如果定义和实现是在同一个文件（比如说 CTest.h）中，那么编译器在编译时就可以寻找到模板的实现体。
- 声明和定义分离，但是在定义所在文件中添加实例化声明：template class CTest<int>;
  此编译器在编译 CTest.cpp 时，会在 CTest.obj 加入对应实现体的二进制代码（因为此时 T 已知）。
  所以在链接时，链接器可以找到该模板类的具体实现。

- 对于普通对象或者函数而言，声明和实现可以分离到 *.h 和 *.cpp中去，其中 CommonClass.cpp 会include这个 CommonClass.h，
  因为编译器会根据 CommonClass.cpp 生成对应 CommonClass.obj，因此 obj 文件中会包含实现体对应的二进制代码。
  如果现有 main.cpp 使用了该类生成的对象，那么链接器可以在 CommonClass.obj 找到实现体对应的二进制代码。


