问：C++11之后返回std::vector时会自动调用std::move吗？
会优化。但这种情况不会调用move的构造。现代编译器会对此做优化，准确说是会发生拷贝消除(copy elison)，copy elision的成本比低开销的move还要低。

问：STL如何实现vector？
- vector支持随机访问，内部使用动态数组来实现
- 当进行insert或push_back操作时，如果此时内存不够用，会动态的重新分配，一般是当前大小的1.5~2倍，然后把原来的内容拷贝过去
- 内部有allocator类进行内存管理，不需要程序员手动操作。

问：vector的push_back过程详解？
- 一般对容器的内存分配和构造是分开的2个过程，STL有专门的空间配置器负责分配内存，
  而构造则是通过placement new在已申请的内存上进行的
- 调用 拷贝构造函数 把a赋值给vec的finish迭代器指向的内存，说白了就是vec中存放的a和上面定义的a对象已经不是一个东西了。
- 默认初始化的vector是不分配内存空间的，当push_back发现vector空间不足以容纳新元素时，就会分配新的空间（通常是加倍），
  将数据移动到新空间时就会发生 移动构造函数，而当我们用vs.reserve()预留足够的空间时，就不会发生移动构造函数了。

问：使用reserve来避免不必要的重新分配
reserve成员函数能使你把重新分配的次数减少到最低限度，从而避免了重新分配和指针、迭代器、引用失效带来的开销
reserve()用来保留（扩充）容量，他并不改变容器的有限元素个数；
resize()则调整容器大小（size, 有效元素的个数），而且有时候会增大容器的容量。
capacity容量是为了减少那些使用连续空间（线性空间）存储元素的容器在增加元素时重新分配内存空间的次数的一种机制

问：std::nth_element(std::begin(numbers), std::begin(numbers) + count, std::end(numbers) , std::greater<>());
总结一下你的排序选择：
如果你需要在vector、string、deque或数组上进行完全排序，你可以使用sort或stable_sort。
如果你有一个vector、string、deque或数组，你只需要排序前n个元素，应该用partial_sort。
如果你有一个vector、string、deque或数组，你需要鉴别出第n个元素或你需要鉴别出最前的n个元素，
而不用知道它们的顺序，nth_element是你应该注意和调用的。
如果你需要把标准序列容器的元素或数组分隔为满足和不满足某个标准，你大概就要找partition或stable_partition。
如果你的数据是在list中，你可以直接使用partition和stable_partition，你可以使用list的sort来代替sort和stable_sort。
如果你需要partial_sort或nth_element提供的效果，你就必须间接完成这个任务，但正如我在上面勾画的，会有很多选择。

问：vector中的erase方法与algorithm中的remove有什么区别？
- erase是真正删除了元素，迭代器不能访问了
- remove只是简单的把要remove的元素移到了容器的最后，无法做到真正的删除
capacity()返回的就是包括缓冲区在内的空间大小，而size()返回的就是当前实际使用的空间大小。
如果想强制释放那就新建一个空的vector，然后对这个vector使用swap讲内存交换，那么原来的vector就会释放

问：list 和 vector有什么区别？
- vector支持随机存取，但插入和删除效率低
- list不支持随机存取，但插入和删除效率高

问：vector 和 deque有什么区别？如何选择？
- deque比vector多了push_front()和pop_front()
- deque不存在capacity()和reserve()
- deque中的内存是分段连续的

问：stl里deque是如何实现的？（提问概率：★★★）
deque是一个动态开辟的二维数组。
其实deque由一段一段内存构成的，他是分段连续,而不是内存连续。当走向段的尾端时候自动跳到下一段。
map记录着一系列的固定长度的数组的地址，这个map仅仅保存的是数组的地址,真正的数据在数组中存放着。
deque先从map中央间的位置(因为双向队列，前后都可以插入元素，前面需要留出一定的空间)找到一个数组地址，向该数组中放入数据，
数组不够时继续在map中找空闲的数组来存数据。当map也不够时重新分配内存当作新的map，把原来map中的内容copy的新map中。
所以使用deque的复杂度要大于vector，尽量使用vector。
总结：deque的头插头删，尾插尾删还是比较快的，但是其他位置的删除和增加特别麻烦，它的查找速率较为缓慢，因为要遍历！

问：STL中的priority_queue的实现？
priority_queue，优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，
在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面。
底层容器使用的是一般为vector为底层容器，堆heap为处理规则来管理底层容器实现。

问：STL迭代器如何实现？
1、 迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，
除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。
2、 迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历。

问：迭代器失效？
1. map移除元素会让迭代器失效
2. map增加元素并不会使迭代器失效, 因为map增加元素跟vector不一样, 
   vector要重新找一块内存把当前所有元素复制过去并释放原有元素所以会导致vector的迭代器失效, 
   但是map只是直接在红黑树上增加一个结点而已, 并不会移动原有元素, 内存没动, 自然map的迭代器不会失效了。

问：STL中map内部如何实现的？
map底层是 红黑树 实现的。
红黑树： 节点为红色or黑色
		叶子节点是空节点，黑色
		根节点是黑色
		如果父节点是红色，那么两个子节点都是黑色
		节点到其子孙节点的每条简单路径上都包含着相同数目的黑色节点

问：map插入方式有几种？
1)  用insert函数插入pair数据，
mapStudent.insert(pair<int, string>(1, "student_one")); 
2)  用insert函数插入value_type数据
mapStudent.insert(map<int, string>::value_type (1, "student_one"));
3)  在insert函数中使用make_pair()函数
mapStudent.insert(make_pair(1, "student_one")); 
4)  用数组方式插入数据
mapStudent[1] = "student_one"; 

问：map 和 hashmap有什么区别？
map分为有序map和无序map（unordered_map），实现的基本数据结构分别是红黑树与哈希表。
- map的底层是红黑树，hashmap的底层是哈希表
- map中元素可以自动按照键值排序，hashmap各项操作平均复杂度接近常数
- map属于标准库的一部分，hashmap不是
hashmap里面常说的桶bucket就是vector数组的一个元素，每个桶里面的数据是以链表(开链)的形式存储，
进一步来说这些操作与定义都是通过一个基本的数据结构hashtable来实现的，
hashtable里面的hash函数就是常说的取模函数，根据存储数据key值对桶的长度取余数来存放。
改变桶的数量就相当于改变Vector的长度，如果超过vector的capacity就会调用Vector的扩容机制
（但是实际上他每次hash的时候都会直接调用vector的reserve进行扩容）。 

问：hashtable中解决冲突有哪些方法？
记住前三个：
线性探测
使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位
开链
每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中
再散列
发生冲突时使用另一种hash函数再计算一个地址，直到不冲突
二次探测
使用hash函数计算出的位置如果已经有元素占用了，按照、、…的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测
公共溢出区
一旦hash函数计算的结果相同，就放入公共溢出区

问：红黑树基本概念
1、它是二叉排序树（继承二叉排序树特显）：
若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。
若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。
左、右子树也分别为二叉排序树。
2、它满足如下几点要求：
树中所有节点非红即黑。
根节点必为黑节点。
红节点的子节点必为黑（黑节点子节点可为黑）。
从根到NULL的任何路径上黑结点数相同。
3、查找时间一定可以控制在O(logn)。

各种排序算法性能比较
- 一般来说，当数据规模较小时，直接选择 插入排序 和 冒泡排序
- 对于大部分有序的数据，不宜使用快排；快排适合大量随机数据的排序。
复杂度：O(n^2): 冒泡、选择、插入
       O(nlogn): 快排、归并、堆排序


