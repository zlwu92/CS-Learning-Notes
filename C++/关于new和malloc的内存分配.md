问：简要说明C++的内存分区
>C++中的内存分区，分别是栈、堆(new)、自由存储区(malloc)、全局/静态存储区、常量存储区和代码区。依次从高地址->低地址

问：内存分配的方式有几种？
- 从静态存储区分配：编译期就分配好，在整个运行期都存在
- 在栈上创建：函数内部的局部变量
- 在堆上创建：生命期由程序员控制

问：new 和 malloc的区别？
- new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持；
- 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。
- new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。
而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
- new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
- new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。
>delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。
malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

问：malloc的底层实现
- 当开辟的空间小于 128K 时，调用 brk()函数，malloc 的底层实现是系统调用函数 brk()，
  其主要移动指针 _enddata(此时的 _enddata 指的是 Linux 地址空间中堆段的末尾地址，不是数据段的末尾地址)
- 当开辟的空间大于 128K 时，mmap()系统调用函数来在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟。

问：有了malloc/free，为什么还要new/delete？
>对于非内置数据类型的对象，对象在销毁之前要自动执行析构函数，
而malloc/free是库函数不是运算符，不在编译器控制范围，
不能把构造函数和析构函数强加于malloc/free，只能使用new/delete运算符