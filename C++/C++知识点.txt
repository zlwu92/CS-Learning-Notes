C++知识点：
1. ++i 和 i++ 哪个效率更高？
内置数据类型，效率没有区别；自定义类型，++i效率较高
++i先自增1，再返回；i++先返回，再自增1

2. const 和 #define 的特点和区别？
#define只是用来做文本替换的，编译期概念。 存在于程序的代码段，无类型检测。
const存在于程序的数据段，在堆栈分配空间，是一个运行时的概念，可以做类型检查。

3. const 有什么作用？
- const用于定义常量，可以进行数据静态类型安全检查
- const用于修饰函数形参，当传入自定义类型和抽象类型时，应该用const&，避免产生临时对象，提高效率
- const修饰函数的返回值，则返回值不能被修改
- const修饰类的成员函数
- 对于全局变量，const存于全局区，对于字面值常量，存于常量存储区，对于局部变量，存于栈区

mutable关键字:
- 被mutable修饰的变量，将永远处于可变的状态
- mutable在类中只能够修饰非静态数据成员
- 我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。
  但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。
- const方法中不允许对常规成员进行变动，但mutable成员不受此限制
volatile关键字:
- “易变”是相对与普通变量而言其值存在编译器(优化功能)未知的改变情况(即不是通过执行代码赋值改变其值的情况)
  而是因外在因素引起的，如多线程，中断等。
- volatile用于修饰成员或变量，指示其修饰对象可能随时变化，编译器不要对所修饰变量进行优化(缓存)，每次取值应该直接读取内存。
总结：
- mutable只能用与类变量，不能与const同时使用；在const修饰的方法中，mutable变量数值可以发生改变；
- volatile只是运行期变量的值随时可能改变，这种改变即可能来自其他线程，也可能来自外部系统。

4. static关键字的作用？
- 在函数体内，一个被声明为static的变量在函数调用中保持不变；
- 在模块内（但在函数体外），一个被声明为static的变量是一个本地cpp的全局变量；
- 在模块内，一个被声明为static的函数只可被本模块内的其他函数调用；

简述extern"C"的作用
- extern用来声明或者引用一个全局变量
- C函数需要利用extern "c"进行链接指定，告诉编译器，不要改变我的名字。
- 由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；
  而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般之包括函数名。

5. static全局变量与普通的全局变量有什么区别？
- static全局变量只初始化一次，为0，防止在其他文件中被引用
- static函数在内存中只有一份，保存在静态存储区，生命周期整个程序运行期间，普通函数每次被调用时都会维持一份copy
- 类的static成员供所有对象使用，不是对象的成员，因此引用不需要对象名。static函数不能调用非static成员。

6. C 和 C++ 的区别？
C 是面向过程的结构化语言，重点是算法和数据结构的input与output
C++ 在保留C的基础上，引入了面向对象的设计思想，考虑构造对象模型，数据封装，接口设计，继承多台的使用；
	还增加了许多类型安全的功能，比如强制类型转换，还有泛型编程，模板类，函数模板等；

7. 为什么要引入inline函数？
- 主要目的是 用它替代 C中的宏定义（缺点是 不能对参数进行有效的检测，返回值也不能被强制转换，存在隐患和局限）

8. inline比宏定义的优势在哪？
- inline定义的类的函数，代码是被放入符号表中的，在使用时直接进行替换（像宏一样展开），无调用开销
- inline函数也是函数，编译器会对其进行一些列检查，消除了安全隐患
- inline作为成员函数时，还能使用类中的protected和private成员变量

9. inline与宏的区别在哪？
- inline在 编译 时展开，宏在 预编译 时展开
- inline是函数，宏不是函数
- 编译时，inline函数直接被镶嵌到目标代码中，宏只是一个简单的文本替换

10.inline函数的使用场合
通常把类中对于protected和private的成员的读写操作接口定义成inline

11.为什么不把所有函数定义成inline？
inline是以代码膨胀为代价的，仅仅是省去了函数调用的开销。
- if 函数体内代码很大，inline导致内存开销大
- if 函数体内出现循环，执行函数体内的代码比函数调用开销大
- 不应该把constructor和destructor定义成inline，不应该出现在类的声明中

12.指针和引用有什么区别？
- 初始化要求不同，引用必须初始化。
- 可修改性不同，引用初始化后不可改变，指针可以随时改变
- 不存在NULL引用，指针可以
- 测试需要的区别，引用不需要测试合法性，指针需要测试

13.为什么传引用比传指针安全？
指针可以随时指向别的对象，可以不初始化，可能产生野指针

14.指针常量 和 常量指针的区别？
常量指针：指向常量的指针，所指内容不可修改；const int* p; or int const* p;
指针常量：是不可改变地址的指针，但可以对他所指内容进行修改，int * const p;

15.什么是this指针？
对于一个类的实例来说，你可以看到它的成员函数、成员变量， 　　
对于一个实例本身，this是一个指针，它时时刻刻指向你这个实例本身。
作用域：this指针是编译器默认传给类中非静态函数的隐含形参，所以其作用域在非静态成员函数的函数体内。
this是一个常量指针，成员函数的其它参数正常都是存放在栈中。而this指针参数则是存放在 register 中。
- 类的非static函数是类的对象，含有this指针；而类的static函数属于类的本身，不含this指针
- friend函数是非成员函数，无法通过this指针获取

16.指针数组 和 数组指针的区别？
指针数组：是一个数组，数组中的每个元素都是指针 int* p[10];
数组指针：是一个指针，指向一个数组的首地址 int* p = new int[10];

17.函数指针 和 指针函数的区别？
指针函数：是返回指针类型的函数 void *func(){ return pointer;}
函数指针：是指向函数地址的指针 void (*p)(int, int);
typedef关键字可以定义一个函数指针类型；

18.什么是“野指针”？
野指针 不是 NULL 指针，而是指向“垃圾”内存的指针
- 指针没有被初始化
- 指针被free或者delete以后，没有置为NULL

19.malloc的底层实现
- 当开辟的空间小于 128K 时，调用 brk()函数，malloc 的底层实现是系统调用函数 brk()，
  其主要移动指针 _enddata(此时的 _enddata 指的是 Linux 地址空间中堆段的末尾地址，不是数据段的末尾地址)
- 当开辟的空间大于 128K 时，mmap()系统调用函数来在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟。

20.有了malloc/free，为什么还要new/delete？
对于非内置数据类型的对象，对象在销毁之前要自动执行析构函数，
而malloc/free是库函数不是运算符，不在编译器控制范围，
不能把构造函数和析构函数强加于malloc/free，只能使用new/delete运算符

21.内存分配的方式有几种？
- 从静态存储区分配：编译期就分配好，在整个运行期都存在
- 在栈上创建：函数内部的局部变量
- 在堆上创建：生命期由程序员控制

22.strcpy 和 memcpy的区别？
- 复制内容不同，memcpy可以复制任何存于内存的内容
- 复制方法不同，strcpy不需要指定长度，memcpy需要传参
- 用途不同，复制字符串用strcpy，其他考虑memcpy
手动实现strcpy
char *strcpy(char *strDest, const char *strSrc)
{
	if ( strDest == NULL || strSrc == NULL)
		return NULL ;
	if ( strDest == strSrc)
		return strDest ;
	char *tempptr = strDest ;
	while( (*strDest++ = *strSrc++) != ‘/0’)	return tempptr ;
}

23.memcpy的源地址与目的地址有交集会有影响吗，如何解决？
从最后一个字节倒着开始复制。

24.判断处理器 大端 和 小端？
- 小端的CPU对操作数的存放方式是：从低字节 到 高字节；数据的低字节存储在低地址中
- 大端的CPU对操作数的存放方式是：从高字节 到 低字节；数据的高字节存储在低地址中
- 联合体union的存放顺序是从低地址开始存放的
方式一：使用强制类型转换-这种法子不错
int main()
{
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout << "big endian" << endl;
    else if(c == 0x34)
        cout << "little endian" << endl;
}

问：memory alignmentand padding, 内存对齐的原理与意义（提问概率：★★★★）
结构体以及类成员对齐，意义就是减少cpu读取的次数，提高效率。
比如一个int变量长度为4个字节，cpu一次读4个字节，当然是一次读取比较好。
但是如果前面有一个char，地址为0-1。那么这个int的地址就为1-4。导致cpu，分两次读取int值。 
具体的对齐规则，要说的非常准确可能比较麻烦，简单来讲就是，每个变量看后面的变量，如果后面的变量大，就和后面的大小对齐并补充字节。
最后一个变量，按照成员内最大的对齐值，对齐并补充字节。
问：如何让数组首地址按照32字节对齐？
(arr + 31) & E0 --> E0 = 1110 0000，按照32字节对齐，就是要首地址被32整除，则需要最后5个bit为0；

如何关闭内存对齐呢？
添加预处理指令 #pragma pack(1) 
/////////////////////////////////////////////////////////////////////////////////

25.class 和 struct有什么区别？
- C中的struct只是一种复杂数据类型定义
- C++中的struct中成员都是public的，class不然，还可以表示模板

问：final和override的作用，以及使用场合（提问概率：★★）
final:禁止继承该类或者覆盖该虚函数
override:必须覆盖基类的匹配的虚函数
场合（final）:不希望这个类被继承，比如vector，编码者可能不够了解vector的实现，或者说编写者不希望别人去覆盖某个虚函数
场合（override）:第一种，在使用别人的函数库，或者继承了别人写的类时，想写一个新函数，可能碰巧与原来基类的函数名称一样，被编译器误认为要重写基类的函数。第二种情况是想覆写一个基类的函数，但是不小心参数不匹配或者名字拼错，结果导致写了一个新的虚函数

问：描述一下C/C++代码的编译过程？（提问概率：★★★★）
预处理——编译——汇编——链接。
预处理器先处理各种宏定义，然后交给编译器；
编译器编译成.s为后缀的汇编代码；
汇编器将汇编代码转成.o为后缀的机器码（二进制）；
最后通过链接器将一个个目标文件（库文件）链接成一个完整的可执行程序（或者静态库、动态库）。

26.C++空类中默认会产生哪些成员函数？
默认构造函数，复制构造函数，析构函数，赋值函数，取值运算。

27.构造函数 和 析构函数是否可以被重载？
构造函数可以被重载，且可以带参数
析构函数只能有一个，无参

28.构造函数内调用构造函数只是在栈上生成了一个临时对象，对自己毫无影响

/////////////////////////////////////////////////////////////////////////////////

29.构造函数的explicit与普通构造函数的区别？
普通构造函数能被 隐式调用，而explicit构造函数只能被显示调用。

30.什么是多态？
同一操作作用于不同的对象，可以有不同的解释和结果。

31.重载和覆盖有什么区别？
重载：子类改写了父类的方法。 
	 函数名相同，参数列表不同，返回值类型也可以不同。
	 重载在编译期完成
覆盖：同一个函数的不同版本，参数不同。 
	 只有虚函数才能被覆盖，函数名、参数列表、参数类型都相同
	 覆盖在运行期发生
重载实现编译时多态，虚函数实现运行时多态。

32.什么是虚函数？
在基类用virtual声明成员函数为虚函数。
这样就可以在派生类中重新定义此函数，为它赋予新的功能，并能方便地被调用
当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。

33.虚函数是怎么实现的？
- 通过虚函数表实现。
- 如果一个类中含有虚函数，则系统会为这个类分配一个指针指向一张虚函数表，
  表中每一项都指向一个虚函数的地址，实现上就是一个函数指针的数组。
- 在类对象的内存布局中，首先是vtbl指针，然后才是对象具体数据
  运行期间，根据具体对象获取正确的vtbl，从而调用正确的虚函数，实现多态性。
虚函数指针：在含有虚函数类的对象中，指向虚函数表，在 运行 时确定。
虚函数表：是一个存储虚函数地址的数组,以NULL结尾
		 在程序只读数据段（.rodata section，见：目标文件存储结构），
		 存放虚函数指针，如果派生类实现了基类的某个虚函数，
		 则在虚表中覆盖原本基类的那个虚函数指针，在 编译 时根据类的声明创建。
相同类型的所有对象公用一个虚函数表，在单继承下不管有多少虚函数表指针。
覆盖：就是为派生类构造虚函数表时用派生类的函数地址替换基类成员函数地址的过程。

34.如何实现多态？
- 编译时多态，由函数重载来完成。
- 运行时多态，通过虚函数来实现。

35.C++的构造函数为何不能为虚函数？（vtable在构造函数调用后才建立，因而构造函数不可能成为虚函数）
- 存储空间角度：虚函数对应一个vtable，vtable存储于对象的内存空间
  若构造函数是虚的，则需要通过 vtable来调用，若对象还未实例化，即内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。
- 使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。
  构造函数本身就是要初始化实例，那使用虚函数就没有实际意义
- 从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；
  而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数
- 构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型

为什么析构函数不能抛出异常？
1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如 资源泄漏 的问题。
2）通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。
Solutions：
1) 如果某个操作可能会抛出异常，class应提供一个普通函数（而非析构函数），来执行该操作。目的是给客户一个处理错误的机会。
2) 如果析构函数中异常非抛不可，那就用try catch来将异常吞下，
   必须要把这种可能发生的异常完全封装在析构函数内部，决不能让它抛出函数之外。

为什么构造函数失败应该抛出异常？
构造函数可以抛出异常，new运算符保证不会出现内存泄漏，底层实现会在catch中抛出异常
构造函数private -- 主要目的就是避免外部构造此类。

如何避免使用c++的拷贝构造函数？
不采用值拷贝（尽量用引用拷贝）

为什么虚函数遇到构造析构就退化了？
在构造函数和析构函数中调用的虚函数并不具备虚函数的特性
因为基类的构造函数先构造，析构函数后析构

为什么不要在构造函数 和 析构函数中调用虚函数？（因为这种情况下的虚函数调用不会调用到外层派生类的虚函数！）
- 基类部分在派生类部分之前被构造，当基类构造函数执行时派生类中的数据成员还没被初始化。
  如果基类构造函数中的虚函数调用被解析成调用派生类的虚函数，
  而派生类的虚函数中又访问到未初始化的派生类数据，将导致程序出现一些未定义行为和bug。
- 基类中虚函数调用能调用得到派生类的虚函数，那么派生类的虚函数将访问一些已经“无效”的数据，
  所带来的问题和访问一些未初始化的数据一样。而同样，我们可以认为在析构的过程中，虚函数表也是在不断变化的。

36.C++中虚析构函数的作用是什么？
为了正确释放派生类的资源，因此，只有当一个类作为基类的时候，才把析构函数声明为虚函数

如果在一个函数内定义一个 static 对象，什么时候执行构造和析构函数？如果这个函数从没被调用，会怎么被析构？
- 执行函数时，首先调用构造函数，但函数结束并不会调用析构函数，因为此对象是static 并不会被销毁，在主函数退出之后，执行析构函数。
- 当不调用函数时，构造函数和析构函数都不会执行。

注意：在析构函数中delete释放的资源，其拷贝构造函数必须使用 深拷贝！

C++构造函数参数列表初始化与直接在函数内部初始化有何区别？
- 先进行列表初始化然后才会进入构造函数体内。函数体内再赋值是重复的，低效的，一般建议成员列表初始化。
- 注意：实例化一个类（如Base base）的时候实质上会发生5步，
  1.分配memory给对象base
  2.调用类Base相应的构造函数
  3.先进行初始化列表的初始化
  4.再进入构造函数体内，进行一些赋值什么的
  5.跳出函数体，控制权还给调用者

37.为什么需要多重继承？它的优缺点是什么？
一些事物需要两个或者以上事物的属性。
优点：对象可以调用多个基类的接口
缺点：继承上容易出现二义性，即同一个成员在两个基类中名字相同，无法区分继承自哪一个

38.多继承二义性的消除
虚继承，这样系统会自动线加入一个虚基类的拷贝，只生成一份拷贝，故消除了二义性。

39.虚函数 和 纯虚函数有什么区别？
- 虚函数是要被实现的，为了让他在子类中被覆盖，后期绑定实现多态；纯虚函数只是一个接口，留到子类中实现。
- 虚函数在子类里必须被实现；带纯虚函数的类为抽象类，不能实例化对象，只能被继承，析构函数可以为纯虚的！

在虚继承中，由 最底层派生类 的构造函数 初始化 虚基类
虚基类并不是在声明基类时声明的，而是在声明 派生类 时，指定继承方式声明的。
有了多继承，就存在菱形继承，有了菱形继承就有菱形虚拟继承
首先按声明顺序检查直接基类，看是否有 虚基类（发现D,E存在虚基类），先初始化 虚基类（例中首先初始化C和E）。
一旦虚基类构造完毕，就按声明顺序调用 非虚基类 的构造函数（例中ABDF），析构的调用次序和构造调用次序相反。
虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体！
/////////////////////////////////////////////////////////////////////////////////

40.拷贝构造函数是什么？什么是深拷贝和浅拷贝？
浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址；
深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值。
- 拷贝构造函数是有编译器调用完成一些基于同一类的其他对象的构建和初始化
- 浅复制：指让新旧两个对象指向同一个外部的内容；
- 深复制：指为新对象制作了外部对象的独立复制；
拷贝构造函数 与 赋值构造函数有什么区别？
- 拷贝构造是一个对象来初始化一块内存区域 => A a; A b = a，
  而赋值函数是对一个已经被初始化的对象进行operator=操作 => A a; A b; b = a;
  拷贝构造函数是函数，赋值运算符是运算符重载！
- 拷贝构造函数大多数情况下是copy，赋值函数则是引用对象
- 拷贝构造调用的时候通过参数传入对象来产生对象，赋值函数顾名思义赋值，先把原有对象内存释放

41.拷贝构造函数 和 析构函数
构造函数和析构函数是成对的，而函数返回时生成的 临时对象 是有拷贝构造函数生成的。

42.拷贝构造函数与移动构造函数的区别：
拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用
拷贝构造函数完成的是整个对象或变量的拷贝，
而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝节省时间和内存空间。

////////////////////////////////////////////////////////////////////////////////

43.各种排序算法性能比较
- 一般来说，当数据规模较小时，直接选择 插入排序 和 冒泡排序
- 对于大部分有序的数据，不宜使用快排；快排适合大量随机数据的排序。
复杂度：O(n^2): 冒泡、选择、插入
       O(nlogn): 快排、归并、堆排序

44.使用模板有什么缺点？如何避免？
- 模板是节省时间和避免代码冗余的方法
- 但不当的使用，会导致代码膨胀，严重影响程序的运行效率。（把模板中与参数无关的代码分离出来）

函数模板与类模板有什么区别？
- 函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定，
  即函数模板允许隐式调用和显式调用，而类模板只能显示调用。
- 注意：模板类的函数声明和实现必须都在 .h 头文件中完成，编译器实例化它时需要看到该模板的完整定义，所以都放在头文件中

45.STL如何实现vector？
- vector支持随机访问，内部使用动态数组来实现
- 当进行insert或push_back操作时，如果此时内存不够用，会动态的重新分配，一般是当前大小的1.5~2倍，然后把原来的内容拷贝过去
- 内部有allocator类进行内存管理，不需要程序员手动操作。

vector的push_back过程详解？
- 一般对容器的内存分配和构造是分开的2个过程，STL有专门的空间配置器负责分配内存，
  而构造则是通过placement new在已申请的内存上进行的
- 调用 拷贝构造函数 把a赋值给vec的finish迭代器指向的内存，说白了就是vec中存放的a和上面定义的a对象已经不是一个东西了。
- 默认初始化的vector是不分配内存空间的，当push_back发现vector空间不足以容纳新元素时，就会分配新的空间（通常是加倍），
  将数据移动到新空间时就会发生 移动构造函数，而当我们用vs.reserve()预留足够的空间时，就不会发生移动构造函数了。

46.list 和 vector有什么区别？
- vector支持随机存取，但插入和删除效率低
- list不支持随机存取，但插入和删除效率高

47.vector 和 deque有什么区别？如何选择？
- deque比vector多了push_front()和pop_front()
- deque不存在capacity()和reserve()
- deque中的内存是分段连续的

问：stl里deque是如何实现的？（提问概率：★★★）
deque是一个动态开辟的二维数组。
其实deque由一段一段内存构成的，他是分段连续,而不是内存连续。当走向段的尾端时候自动跳到下一段。
map记录着一系列的固定长度的数组的地址，这个map仅仅保存的是数组的地址,真正的数据在数组中存放着。
deque先从map中央间的位置(因为双向队列，前后都可以插入元素，前面需要留出一定的空间)找到一个数组地址，向该数组中放入数据，
数组不够时继续在map中找空闲的数组来存数据。当map也不够时重新分配内存当作新的map，把原来map中的内容copy的新map中。
所以使用deque的复杂度要大于vector，尽量使用vector。
总结：deque的头插头删，尾插尾删还是比较快的，但是其他位置的删除和增加特别麻烦，它的查找速率较为缓慢，因为要遍历！

问：STL迭代器如何实现？
1、 迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，
除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。
2、 迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历

48.STL中map内部如何实现的？
map底层是 红黑树 实现的。
红黑树： 节点为红色or黑色
		叶子节点是空节点，黑色
		根节点是黑色
		如果父节点是红色，那么两个子节点都是黑色
		节点到其子孙节点的每条简单路径上都包含着相同数目的黑色节点

49.map 和 hashmap有什么区别？
map分为有序map和无序map（unordered_map），实现的基本数据结构分别是红黑树与哈希表。
- map的底层是红黑树，hashmap的底层是哈希表
- map中元素可以自动按照键值排序，hashmap各项操作平均复杂度接近常数
- map属于标准库的一部分，hashmap不是
hashmap里面常说的桶bucket就是vector数组的一个元素，每个桶里面的数据是以链表(开链)的形式存储，
进一步来说这些操作与定义都是通过一个基本的数据结构hashtable来实现的，
hashtable里面的hash函数就是常说的取模函数，根据存储数据key值对桶的长度取余数来存放。

改变桶的数量就相当于改变Vector的长度，如果超过vector的capacity就会调用Vector的扩容机制
（但是实际上他每次hash的时候都会直接调用vector的reserve进行扩容）。 

50.vector中的erase方法与algorithm中的remove有什么区别？
- erase是真正删除了元素，迭代器不能访问了
- remove只是简单的把要remove的元素移到了容器的最后，无法做到真正的删除
capacity()返回的就是包括缓冲区在内的空间大小，而size()返回的就是当前实际使用的空间大小。
如果想强制释放那就新建一个空的vector，然后对这个vector使用swap讲内存交换，那么原来的vector就会释放

51.智能指针如何实现？
- 每次创建类的新对象时，初始化指针并将引用计数 = 1；
- 当创建对象的副本时，拷贝构造函数拷贝指针并增加与之对应的引用计数；
- 对象进行赋值时，赋值操作减少左操作数的引用计数，增加右操作数的引用计数；
- 调用析构函数时，减少引用计数，如果为0，则删除对象；
- 重载的->以及*操作符，使得智能指针有类似于普通指针的操作

52.说说unique_ptr？
unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。
采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。
一旦拥有着被销毁或变成 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。
一个unique_ptr独享它指向的对象。 也就是说，同时只有一个unique_ptr指向同一个对象，
当这个unique_ptr被销毁时，指向的对象也随即被销毁。
unique_ptr不可复制，赋值，但是move()可以转换对象的所有权

问：shared_ptr的实现，reference count在哪里定义（提问概率：★★★）
shared_ptr ，多个指针指向相同的对象，std::make_shared 消除显式地使用 new
shared_ptr作为一种智能指针，本质上一个模板类，表现上与指针相同，是因为重载了&以及*这两个运算符（当然还有=等运算符）。
由于其本身的计数机制，防止资源泄露上面很有意义。
shared_ptr在实现上有两个核心的成员，一个是指向资源对象的指针变量，另一个是指向引用计数的指针变量。
另外，原生的shared_ptr的读写在多线程当中是不安全的，因为读写不具有原子性，所以多线程使用shared_ptr一定要加锁。
循环引用会造成内存泄露。

为了解决循环引用导致的内存泄漏，引入weak_ptr，不会修改引用计数的值。
weak_ptr是为了配合shared_ptr而引入的一种智能指针，它不增加引用计数，只要出了作用域就会自动析构！
weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。
但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。
使用weak_ptr的成员函数use_count()可以观测资源的引用计数，
另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。
weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。
但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。

RAII是什么？全称呢？和智能指针什么关系？
RAII:Resource Acquisition Is Initialization 资源分配即初始化，利用构造函数和析构函数定义一个类来完成对资源的分配和释放
智能指针主要用来防止内存泄漏
智能指针的思想就是RAII，就是利用对象的生命周期来管控资源的一种方式。
在对象构造时获取资源，把资源交给对象管理，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象析构的时候释放资源。
实际上是把管理一份资源的责任托管给了一个对象。
这种做法有两大好处：
不需要显式地释放资源；采用这种方式，对象所需的资源在其生命期内始终保持有效。

53.说说运行时类型信息 (RTTI)
dynamic_cast	用于多态类型的转换，只适用于指针或引用，向下转型是安全的
typeid 运算符允许在运行时确定对象的类型
type_id 返回一个 type_info 对象的引用
如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数
只能获取对象的实际类型
type_info 类描述编译器在程序中生成的类型信息。此类的对象可以有效存储指向类型的name的指针。
type_info 类还可存储适合比较两个类型是否相等 或 比较其排列顺序的编码值。
类型的编码规则和排列顺序是未指定的，并且可能因程序而异。
头文件：typeinfo

54.Linux 进程内存区域
代码段：代码段是用来存放可执行文件的操作指令，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。
数据段：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序 static变量 和 全局变量。
BSS段：BSS段包含了程序中未初始化的全局变量，在内存中 bss段全部置零。
堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。
栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

55.git: 
新增文件的命令：git add file或者git add .
提交文件的命令：git commit –m或者git commit –a
查看工作区状况：git status –s
拉取合并远程分支的操作：git fetch/git merge或者git pull
查看提交记录命令：git reflog
通过git pull命令，拉取远程分支上的代码并合并到本地分支，目的是消除冲突
git fetch branch是把名为branch的远程分支拉取到本地；
git pull branch是在fetch的基础上，把branch分支与当前分支进行merge；因此pull = fetch + merge。
如何把本地仓库的内容推向一个空的远程仓库？
git remote add origin XXXX
git push origin master

56.如何用gdb检查内存泄漏？
(gdb) info proc
使用GDB在malloc和free函数设置断点，并打印分配和释放时的内存地址以及调用栈，
然后通过脚本分析分配和释放是否配对来检测是否存在内存泄露以及发生内存泄漏的位置。
Valgrind 现在提供多个工具，其中最重要的是 Memcheck

问：内存泄露是什么意思？如何检测与避免内存泄漏？（提问概率：★★★★）
指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。
内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，
由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费

什么是内存碎片？
描述一个系统中所有的不可用的空闲内存，原因在于空闲内存以小而不连续方式出现在不同的位置。
缺点：大量的内存碎片会使系统缓慢，原因在于虚拟内存的使用会使内存与硬盘之间的数据交换称为系统缓慢的根源,最终造成内存的枯竭!
如何避免内存碎片的产生？
- 少用动态内存分配的函数(尽量使用栈空间)
- 分配内存和释放的内存尽量在同一个函数中
- 尽量一次性申请较大的内存2的指数次幂大小的内存空间，而不要反复申请小内存(少进行内存的分割)
- 使用内存池来减少使用堆内存引起的内存碎片，自己来管理

Linux 内存占用过高时，应该如何排查问题？
答：用top命令查看占用高资源的进程，再用top -Hp pid查看该进程中线程的占用情况，-H 显示线程信息，-p指定pid
用printf查看该线程并jstack打印保存，查看日志找问题，

C++对文件的操作
在fstream类中，成员函数open()实现打开文件的操作，从而将数据流和文件进行关联
输出流：ostream (output stream)
输出流：istream (input stream)
输入输出流：iostream
写操作（输出）的文件类：ofstream
读操作（输入）的文件类：ifstream
可同时读写操作的文件类：fstream (file stream)
ps:为防止流对象被销毁时还联系着打开的文件，析构函数(destructor)将会自动调用关闭函数close

read 和 write函数
分别为istream和ostream的成员函数，前者被ifstream所继承，后者被ofstream所继承。

TODO:
1. 1个G的内存，1个T的uint64乱序数据，一台机器，怎么找他的中位数！
问：在一个文件中有 10G 个整数，乱序排列，要求找出中位数。内存限制为 2G。
法一：不妨假设10G个整数是64bit的。 2G内存可以存放256M个64bit整数。
我们可以将64bit的整数空间平均分成256M个取值范围，用2G的内存对每个取值范围内出现整数个数进行统计。
这样遍历一边10G整数后，我们便知道中数在那个范围内出现，以及这个范围内总共出现了多少个整数。
如果中数所在范围出现的整数比较少，我们就可以对这个范围内的整数进行排序，找到中数。
如果这个范围内出现的整数比较多，我们还可以采用同样的方法将此范围再次分成多个更小的范围
（256M=2^28，所以最多需要3次就可以将此范围缩小到1，也就找到了中数）。

法二：基于字节的桶排序是一个可行的方法
将整形的每1byte作为一个关键字，也就是说一个整形可以拆成4个keys，而且最高位的keys越大，整数越大。
如果高位keys相同，则比较次高位的keys。整个比较过程类似于字符串的字典序。

C++语言级别性能优化
- 在32位的程序中,使用int类型作循环体的索引变量比short类型具有更好的性能。
- 在循环体中尽量少使用指针间接寻址，先将间接寻址的内容放在某个寄存器里面，在循环体内操作完后，再回送到指针所指的内存。
  间接寻址将导致至少两次以上的内存操作，这是其一。其二，由于间接寻址使得指令具有前后的依赖性（只有先获得地址才能够做取内存内容的操作），编译器的优化能力将被降低，同时对处理器中流水线的乱序，调度和指令配对也会有一定的影响
- 如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断移到循环体的外面。
- 将一个循环体内部的浮点除法操作，改成浮点乘法，或许有意想不到的效果。
- 在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放在最外层，以减少CPU 跨切循环层的次数。

