什么是虚函数？
>在基类用virtual声明成员函数为虚函数。
这样就可以在派生类中重新定义此函数，为它赋予新的功能，并能方便地被调用
当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。

虚函数是怎么实现的？
- 通过**虚函数表**实现。
- 如果一个类中含有虚函数，则系统会为这个类分配一个指针指向一张虚函数表，
  表中每一项都指向一个虚函数的地址，实现上就是一个函数指针的数组。
- 在类对象的内存布局中，首先是vtbl指针，然后才是对象具体数据
  运行期间，根据具体对象获取正确的vtbl，从而调用正确的虚函数，实现多态性。
```
虚函数指针：在含有虚函数类的对象中，指向虚函数表，在 运行 时确定。
虚函数表：是一个存储虚函数地址的数组,以NULL结尾
		 在程序只读数据段（.rodata section，见：目标文件存储结构），
		 存放虚函数指针，如果派生类实现了基类的某个虚函数，
		 则在虚表中覆盖原本基类的那个虚函数指针，在 编译 时根据类的声明创建。
相同类型的所有对象公用一个虚函数表，在单继承下不管有多少虚函数表指针。
覆盖：就是为派生类构造虚函数表时用派生类的函数地址替换基类成员函数地址的过程。
```

**超重要!** 
>C++的构造函数为何不能为虚函数？（vtable在构造函数调用后才建立，因而构造函数不可能成为虚函数）
- 存储空间角度：虚函数对应一个vtable，vtable存储于对象的内存空间
  若构造函数是虚的，则需要通过 vtable来调用，若对象还未实例化，即内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。
- 使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。
  构造函数本身就是要初始化实例，那使用虚函数就没有实际意义
- 从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；
  而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数
- 构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型

C++中析构函数为什么要虚函数？
- 为了正确释放派生类的资源，因此，只有当一个类作为基类的时候，才把析构函数声明为虚函数。
- C++中基类采用virtual虚析构函数是为了防止内存泄漏。

构造函数和析构函数可以调用虚函数吗，为什么？
>不提倡，（因为这种情况下的虚函数调用不会调用到外层派生类的虚函数！）
- 基类部分在派生类部分之前被构造，当基类构造函数执行时派生类中的数据成员还没被初始化。
  如果基类构造函数中的虚函数调用被解析成调用派生类的虚函数，
  而派生类的虚函数中又访问到未初始化的派生类数据，将导致程序出现一些未定义行为和bug。
- 基类中虚函数调用能调用得到派生类的虚函数，那么派生类的虚函数将访问一些已经“无效”的数据，
  所带来的问题和访问一些未初始化的数据一样。而同样，我们可以认为在析构的过程中，虚函数表也是在不断变化的。
- 析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。
  所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。
>总结：在构造函数和析构函数中调用的虚函数并不具备虚函数的特性，因为基类的构造函数先构造，析构函数后析构！

为什么虚函数遇到构造析构就退化了？
>在构造函数和析构函数中调用的虚函数并不具备虚函数的特性
因为基类的构造函数先构造，析构函数后析构。

C++中虚析构函数的作用是什么？
>为了正确释放派生类的资源，因此，只有当一个类作为基类的时候，才把析构函数声明为虚函数。

如果在一个函数内定义一个 static 对象，什么时候执行构造和析构函数？如果这个函数从没被调用，会怎么被析构？
- 执行函数时，首先调用构造函数，但函数结束并不会调用析构函数，因为此对象是static 并不会被销毁，在**主函数退出**之后，执行析构函数。
- 当不调用函数时，构造函数和析构函数都不会执行。
