问：C++构造函数的default和delete
C++11中，当类中含有不能默认初始化的成员变量时，可以禁止默认构造函数的生成，
myClass()=delete;//表示删除默认构造函数
myClass()=default;//表示默认存在构造函数，同时提供默认版本和带参自定义版本
当类中含有不能默认拷贝成员变量时，可以禁止默认构造函数的生成，
myClass(const myClass&)=delete;//表示删除默认拷贝构造函数，即不能进行默认拷贝
myClass & operatir=(const myClass&)=delete;//表示删除默认拷贝构造函数，即不能进行默认拷贝

问：C++中delete this是对象先析构还是delete语句先返回？
先析构。

问：构造函数的explicit与普通构造函数的区别？
普通构造函数能被 隐式调用，而explicit构造函数只能被显示调用。

问：为什么在C++里面，一个类的成员函数不能既是 template 又是 virtual 的？
一个C/C++程序就可以被分开编译，然后用一个linker链接起来。这种模型有一个问题，就是各个编译单元可能对另一个编译单元一无所知。
一个 function template最后到底会被 instantiate 为多少个函数，要等整个程序(所有的编译单元)全部被编译完成才知道。同时，virtual
function的实现大多利用了一个"虚函数表"的东西，这种实现中，一个类的内存布局(或者说虚函数表的内存布局)需要在这个类编译完成的时候就被完全确定。
虚函数表没法填！

问：如果想将某个类用作基类，为什么该类必须定义而非声明？
派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。

问：构造函数是否可以放到private里面？
可以定义到private，但定义成private会导致此类不能直接被外部实例化。单例模式就是这样的！

问：抽象基类为什么不能创建对象？
（1）抽象类的定义：称带有纯虚函数的类为抽象类。
抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。
纯虚函数引入原因
 1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。


问：C++的动态绑定和静态绑定
1、对象的静态类型：对象在声明时采用的类型。是在编译期确定的。
2、对象的动态类型：目前所指对象的类型。是在运行期决定的。
3、静态绑定（statically bound）：又名前期绑定（eraly binding），绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；
4、动态绑定（dynamically bound）：又名后期绑定（late binding），绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；
一般的，virtual函数是动态绑定，non-virtual函数是静态绑定，缺省参数值也是静态绑定。

问：什么情况会自动生成默认构造函数？
1) 带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。
2) 带有默认构造函数的基类，如果一个没有任务构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；
3) 带有一个虚函数的类
4) 带有一个虚基类的类
5) 合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。

问：构造函数、析构函数、虚函数可否声明为内联函数？
首先，将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。
register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率。
构造函数和析构函数声明为内联函数是没有意义的；
将虚函数声明为inline，要分情况讨论：
	当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；
	当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下。

问：构造函数初始化列表与构造函数体内复制的区别？
构造函数体中的语句只能将其称作为赋初值，而不能称作初始化。因为初始化只能初始化一次，而构造函数体内可以多次赋值；
构造函数可以分两个阶段进行：（1）初始化阶段；（2）普通计算阶段。
构造函数初始化列表是对类的成员做初始化，而在构造函数体内只是对类的数据成员进行了一次赋值操作。
如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值，而初始化列表只做一次赋值操作。
若类的数据成员是静态的(const)和引用类型，必需用初始化列表；
构造函数体内赋值会带来额外的开销，效率会低于构造函数初始化列表；
注意：实例化一个类（如Base base）的时候实质上会发生5步，
  1.分配memory给对象base
  2.调用类Base相应的构造函数
  3.先进行初始化列表的初始化
  4.再进入构造函数体内，进行一些赋值什么的
  5.跳出函数体，控制权还给调用者


问：什么是多态？
同一操作作用于不同的对象，可以有不同的解释和结果。

问：重载和覆盖有什么区别？
重载：子类改写了父类的方法。 
	 函数名相同，参数列表不同，返回值类型也可以不同。
	 重载在编译期完成
覆盖：同一个函数的不同版本，参数不同。 
	 只有虚函数才能被覆盖，函数名、参数列表、参数类型都相同
	 覆盖在运行期发生
重载实现编译时多态，虚函数实现运行时多态。

问：构造函数 和 析构函数是否可以被重载？
构造函数可以被重载，且可以带参数
析构函数只能有一个，无参

问：什么是虚函数？
在基类用virtual声明成员函数为虚函数。
这样就可以在派生类中重新定义此函数，为它赋予新的功能，并能方便地被调用
当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。

问：虚函数 和 纯虚函数有什么区别？
- 虚函数是要被实现的，为了让他在子类中被覆盖，后期绑定实现多态；纯虚函数只是一个接口，留到子类中实现。
- 虚函数在子类里必须被实现；带纯虚函数的类为抽象类，不能实例化对象，只能被继承，析构函数可以为纯虚的！

问：基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间？
虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成！
C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。
对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。

问：虚函数是怎么实现的？
- 通过虚函数表实现。
- 如果一个类中含有虚函数，则系统会为这个类分配一个指针指向一张虚函数表，
  表中每一项都指向一个虚函数的地址，实现上就是一个函数指针的数组。
- 在类对象的内存布局中，首先是vtbl指针，然后才是对象具体数据
  运行期间，根据具体对象获取正确的vtbl，从而调用正确的虚函数，实现多态性。
虚函数指针：在含有虚函数类的对象中，指向虚函数表，在 运行 时确定。
虚函数表：是一个存储虚函数地址的数组,以NULL结尾
		 在程序只读数据段（.rodata section，见：目标文件存储结构），
		 存放虚函数指针，如果派生类实现了基类的某个虚函数，
		 则在虚表中覆盖原本基类的那个虚函数指针，在 编译 时根据类的声明创建。
相同类型的所有对象公用一个虚函数表，在单继承下不管有多少虚函数表指针。
覆盖：就是为派生类构造虚函数表时用派生类的函数地址替换基类成员函数地址的过程。

问：(超重要!）C++的构造函数为何不能为虚函数？（vtable在构造函数调用后才建立，因而构造函数不可能成为虚函数）
- 存储空间角度：虚函数对应一个vtable，vtable存储于对象的内存空间
  若构造函数是虚的，则需要通过 vtable来调用，若对象还未实例化，即内存空间还没有，无法找到vtable，所以构造函数不能是虚函数。
- 使用角度：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。
  构造函数本身就是要初始化实例，那使用虚函数就没有实际意义
- 从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；
  而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数
- 构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型

问：C++中析构函数为什么要虚函数？
为了正确释放派生类的资源，因此，只有当一个类作为基类的时候，才把析构函数声明为虚函数。
C++中基类采用virtual虚析构函数是为了防止内存泄漏。

问：构造函数和析构函数可以调用虚函数吗，为什么？
不提倡，（因为这种情况下的虚函数调用不会调用到外层派生类的虚函数！）
- 基类部分在派生类部分之前被构造，当基类构造函数执行时派生类中的数据成员还没被初始化。
  如果基类构造函数中的虚函数调用被解析成调用派生类的虚函数，
  而派生类的虚函数中又访问到未初始化的派生类数据，将导致程序出现一些未定义行为和bug。
- 基类中虚函数调用能调用得到派生类的虚函数，那么派生类的虚函数将访问一些已经“无效”的数据，
  所带来的问题和访问一些未初始化的数据一样。而同样，我们可以认为在析构的过程中，虚函数表也是在不断变化的。
- 析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。
  所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。
总结：在构造函数和析构函数中调用的虚函数并不具备虚函数的特性，因为基类的构造函数先构造，析构函数后析构！

问：为什么析构函数不能抛出异常？
1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如 资源泄漏 的问题。
2）通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。
Solutions：
1) 如果某个操作可能会抛出异常，class应提供一个普通函数（而非析构函数），来执行该操作。目的是给客户一个处理错误的机会。
2) 如果析构函数中异常非抛不可，那就用try catch来将异常吞下，
   必须要把这种可能发生的异常完全封装在析构函数内部，决不能让它抛出函数之外。

问：为什么构造函数失败应该抛出异常？
构造函数可以抛出异常，new运算符保证不会出现内存泄漏，底层实现会在catch中抛出异常
构造函数private -- 主要目的就是避免外部构造此类。


问：拷贝构造函数是什么？什么是深拷贝和浅拷贝？
浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址；
深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值。
- 拷贝构造函数是有编译器调用完成一些基于同一类的其他对象的构建和初始化
- 浅复制：指让新旧两个对象指向同一个外部的内容；
- 深复制：指为新对象制作了外部对象的独立复制；

问：拷贝构造函数 与 赋值构造函数有什么区别？
- 拷贝构造是一个对象来初始化一块内存区域 => A a; A b = a，
  而赋值函数是对一个已经被初始化的对象进行operator=操作 => A a; A b; b = a;
  拷贝构造函数是函数，赋值运算符是运算符重载！
- 拷贝构造函数大多数情况下是copy，赋值函数则是引用对象
- 拷贝构造调用的时候通过参数传入对象来产生对象，赋值函数顾名思义赋值，先把原有对象内存释放

问：什么情况下会调用拷贝构造函数？
用类的一个实例化对象去初始化另一个对象的时候
函数的参数是类的对象时（非引用传递）
在c++编译器发生NRV优化，如果是引用返回的形式则不会调用拷贝构造函数，如果是值传递的方式依然会发生拷贝构造函数。

问：拷贝构造函数 和 析构函数有什么联系？
构造函数和析构函数是成对的，而函数返回时生成的 临时对象 是有拷贝构造函数生成的。
注意：在析构函数中delete释放的资源，其拷贝构造函数必须使用 深拷贝！

问：拷贝构造函数与移动构造函数的区别？
拷贝构造函数的形参是一个左值引用，而移动构造函数的形参是一个右值引用
拷贝构造函数完成的是整个对象或变量的拷贝，
而移动构造函数是生成一个指针指向源对象或变量的地址，接管源对象的内存，相对于大量数据的拷贝节省时间和内存空间。

问：为什么需要多重继承？它的优缺点是什么？
一些事物需要两个或者以上事物的属性。
优点：对象可以调用多个基类的接口
缺点：继承上容易出现二义性，即同一个成员在两个基类中名字相同，无法区分继承自哪一个

问：如何消除多继承到二义性？
虚继承，这样系统会自动线加入一个虚基类的拷贝，只生成一份拷贝，故消除了二义性。

问：关于虚继承都知道些什么？
在虚继承中，由 最底层派生类 的构造函数 初始化 虚基类
虚基类并不是在声明基类时声明的，而是在声明 派生类 时，指定继承方式声明的。
有了多继承，就存在菱形继承，有了菱形继承就有菱形虚拟继承
首先按声明顺序检查直接基类，看是否有 虚基类（发现D,E存在虚基类），先初始化 虚基类（例中首先初始化C和E）。
一旦虚基类构造完毕，就按声明顺序调用 非虚基类 的构造函数（例中ABDF），析构的调用次序和构造调用次序相反。
虚拟继承的情况下，无论基类被继承多少次，只会存在一个实体！


问：写一个线程安全的单例模式？
单例模式：其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。
定义一个单例类：
- 私有化它的构造函数，以防止外界创建单例类的对象；
- 使用类的私有静态指针变量指向类的唯一实例；
- 使用一个公有的静态方法获取该实例。

局部静态变量版本在C++11后是线程安全的。
使用函数内的 local static 对象。这样，只有当第一次访问getInstance()方法时才创建实例。
实现：
class Singleton {
public:
  static Singleton& getInstance(){
    static Singleton instance;
    return instance;
  }
private: 
  ～Singleton(){}
  Singleton() = default;

  Singleton() = default;
  Singleton(const Singleton& other) = delete; //禁止使用拷贝构造函数
  Singleton(const Singleton&& other) = delete; // 禁止使用移动构造
  Singleton& operator=(const Singleton&) = delete; //禁止使用拷贝赋值运算符
};


